package myarchive;

import wsiarchive.*;

// Liste von archiv mit dem resultlistCache
public class PairArchiveAndPutResultList implements IArchiveAndPutResultList {
    IArchive archive; // ein archiv
    IPutResultList resultlist; // quasie der Cache
    IArchiveAndPutResultList rest; // rest der liste

    PairArchiveAndPutResultList(IArchive archive, IPutResultList resultlist, IArchiveAndPutResultList rest) {
        this.archive = archive;
        this.resultlist = resultlist;
        this.rest = rest;
    }
    
    // versucht ein item in ein archiv oder den rest zu schreiben
    public IPutResult put(Item item) {
        IPutResult putresult = this.archive.put(item);
        if (putresult instanceof FullPutResult) {
            return this.rest.put(item);
        }
        else {
            // Aktualisiere den Cache
            this.resultlist.addPutResult(putresult);
            return putresult;
        }
    }
    
    
    // schreibt mehrere items in archive
    // @TODO putMultiple funktioniert  noch nicht so wie es soll
    public wsiarchive.IPutResultList putMultiple(wsiarchive.IItemList items) {
        // rekursiv put ausführen
        if (items instanceof wsiarchive.EmptyItemList) {
            return new wsiarchive.EmptyPutResultList();
        }
        // in WORM können wir beliebig oft / lange reinschreiben
        else if (this.archive instanceof WORM) {
            return this.archive.putMultiple(items);
        }
        else {
            // das klappt noch nicht so
            wsiarchive.PairItemList it1 = (wsiarchive.PairItemList) items;
            IItemList items2 = ((IMyArchive)this.archive).getPutAble(it1.toMyItemList());
            IItemList restitems = ((IMyArchive)this.archive).getNotPutAble(it1.toMyItemList());
            wsiarchive.IPutResultList firstresultlist = this.archive.putMultiple(items2.toWSIItemList());
            wsiarchive.IPutResultList restresultlist = this.rest.putMultiple(restitems.toWSIItemList());

//            wsiarchive.IPutResultList restresultlist = this.rest.putMultiple(((PairArchiveAndPutResultList)this.rest).getNotPutAble(it1.toMyItemList()).toWSIItemList()));
            return firstresultlist.toMyPutResultList().append(restresultlist.toMyPutResultList()).toWSIPutResultList();
        }
    }
        
    // gibt die items zurück die reinpassen
    public IItemList getPutAble(IItemList items) {
        if (this.archive instanceof WORM) {
            return items;
        }
        else {
            IItemList itemlist = ((IMyArchive) this.archive).getPutAble(items);
            IItemList itemlist2 = this.rest.getPutAble(items);
            return itemlist.append(itemlist2);
        }
    }
    
    // liefert alle items die geschrieben werden könenn
    public IItemList getNotPutAble(IItemList items) {
        if (this.archive instanceof WORM) {
            return new EmptyItemList();
        }
        else {
            IItemList itemlist = ((IMyArchive) this.archive).getNotPutAble(items);
            IItemList itemlist2 = this.rest.getNotPutAble(items);
            return itemlist.append(itemlist2);
        }
    }

    
    // schreibt ein item in alle teilarchive und liefert die liste er Putresults zurück
    public IPutResultList putAll(Item item) {
        // resultlist cache aktualsieren
        IPutResult putresult = this.archive.put(item);
        this.resultlist.addPutResult(putresult);
        return new PairPutResultList(
           putresult,
            this.rest.putAll(item)
        );
    }

    //gibt Items zurück
    public IGetResult get(IItemId id) {
        // Falls wir ein resultat m
        IGetResult getresult = this.getCache(id);
        if (getresult instanceof NoItemResult) {
            return this.getRekursiv(id);
        }
        else {
            return getresult;
        }
    }
    
    //gibt das die Items im RedundantArchiv in einer GetResultList zurück
     public IGetResult getRedundant(IItemId id) {
        // Falls wir ein resultat m
        IGetResult getresult = this.getCache(id);
        if (getresult instanceof NoItemResult) {
            return this.rest.getRedundant(id);
        }
        else {
            return getresult;
        }
    }
 
    // Versucht ein item ohne benutzern des caches zu bekommen
    public IGetResult getRekursiv(IItemId id) {
        IGetResult getresult = this.archive.get(id);
        if (getresult instanceof NoItemResult) {
            return this.rest.getRekursiv(id);
        }
        else {
            // schreibt die id in den cache, da es ja dort vorhanden ist
            this.resultlist.addPutResult(new OKPutResult(id));
            return getresult;
        }
    }

    // Versucht ein item mit Benutzen des Caches zu bekommen
    public IGetResult getCache(IItemId id) {
        if (this.resultlist.isItemIdIn(id)) {
            return this.archive.get(id);
        }
        else {
            return this.rest.getCache(id);
        }
    }

    // hängt eine liste von archiven an.
    public IArchiveAndPutResultList fillData(IArchiveList archives) {
        if (archives instanceof EmptyArchiveList) {
            return new EmptyArchiveAndPutResultList();
        }
        else {
            return new PairArchiveAndPutResultList(
                archives.getFirst(),
                new EmptyPutResultList(),
                this.fillData(archives.getRest())
                );
            }
    }
}
